// 설정 정보를 DOM에서 가져오기
const chatContainer = document.querySelector('.chat-sidebar-card');
const socketioAvailable = chatContainer ? chatContainer.getAttribute('data-socketio-available') === 'true' : false;
const userIdFromData = chatContainer ? parseInt(chatContainer.getAttribute('data-user-id') || '0', 10) : 0;

let socket = null;
let currentRoomId = null;
let currentUserId = userIdFromData;
window.SOCKETIO_AVAILABLE = window.SOCKETIO_AVAILABLE || socketioAvailable;


// 새 메시지 처리 함수 (통합)
function handleNewMessage(data) {
    console.log('새 메시지 수신:', data);
    
    if (data.room_id == currentRoomId) {
        // 중복 방지: 이미 존재하는 메시지 ID인지 확인 (이중 방어)
        if (data.id) {
            const container = document.getElementById('messages-container');
            const existingMessage = container.querySelector(`[data-message-id="${data.id}"]`);
            if (existingMessage) {
                console.log('[handleNewMessage] 중복 메시지 스킵:', data.id);
                return; // 이미 존재하는 메시지는 추가하지 않음
            }
        }
        
        // 현재 채팅방이면 메시지 추가
        appendMessage(data);
        scrollToBottom();
        
        // 새 메시지 수신 시 읽음 상태 업데이트
        if (socket && socket.connected) {
            socket.emit('mark_read', { room_id: currentRoomId });
        } else {
            fetch(`/api/chat/rooms/${currentRoomId}/mark-read`, {
                method: 'POST'
            }).catch(err => console.error('읽음 상태 업데이트 오류:', err));
        }
    } else {
        // 다른 채팅방이면 알림 표시
        if (data.user_id != currentUserId) {
            fetch(`/api/chat/rooms/${data.room_id}`)
                .then(response => response.json())
                .then(result => {
                    if (result.success && result.room) {
                        showChatNotification(data, result.room);
                    } else {
                        showChatNotification(data, { id: data.room_id, name: '알 수 없는 채팅방' });
                    }
                })
                .catch(err => {
                    console.error('채팅방 정보 조회 오류:', err);
                    showChatNotification(data, { id: data.room_id, name: '알 수 없는 채팅방' });
                });
        }
    }
}

// Socket.IO 초기화 함수
function initializeSocketIO() {
    try {
        if (typeof io === 'undefined') {
            console.error('Socket.IO가 로드되지 않았습니다.');
            return;
        }

        // layout의 싱글톤 소켓을 재사용 (페이지당 소켓 1개 보장)
        if (typeof window.getAppSocket === 'function') {
            socket = window.getAppSocket();
        } else if (window.globalSocket) {
            socket = window.globalSocket;
        } else {
            // fallback: layout 스크립트가 없는 예외 상황에서만 직접 생성
            const fallbackOptions = (typeof window.getAppSocketOptions === 'function')
                ? window.getAppSocketOptions()
                : {
                    transports: ['websocket', 'polling'],
                    upgrade: true,
                    reconnection: true,
                    reconnectionAttempts: Infinity,
                    reconnectionDelay: 1000,
                    reconnectionDelayMax: 5000,
                    timeout: 20000
                };
            socket = io(fallbackOptions);
            window.globalSocket = socket;
            window.__appSocket = socket;
        }

        if (!socket) {
            console.error('Socket.IO 인스턴스를 가져오지 못했습니다.');
            return;
        }

        // 핸들러는 idempotent하게 바인딩해서 중복 등록을 방지
        const handlers = window.__chatSocketHandlers || {
            onConnect: function() {
                console.log('Socket.IO 연결 성공');
                loadRooms();
            },
            onConnectError: function(error) {
                console.error('Socket.IO 연결 오류:', error);
            },
            onDisconnect: function(reason) {
                console.log('Socket.IO 연결 해제:', reason);
                if (reason === 'io server disconnect' && socket) {
                    socket.connect();
                }
            },
            onReconnect: function(attemptNumber) {
                console.log('Socket.IO 재연결 성공:', attemptNumber);
            },
            onNewMessage: function(data) {
                handleNewMessage(data);
            },
            onMessageRead: function(data) {
                if (data.room_id == currentRoomId) {
                    console.log('읽음 상태 업데이트:', data);
                }
            },
            onUserTyping: function(data) {
                if (data.room_id == currentRoomId && data.user_id != currentUserId) {
                    showTypingIndicator(data.user_id, data.is_typing);
                }
            }
        };
        window.__chatSocketHandlers = handlers;

        socket.off('connect', handlers.onConnect);
        socket.off('connect_error', handlers.onConnectError);
        socket.off('disconnect', handlers.onDisconnect);
        socket.off('reconnect', handlers.onReconnect);
        socket.off('new_message', handlers.onNewMessage);
        socket.off('message_read', handlers.onMessageRead);
        socket.off('user_typing', handlers.onUserTyping);

        socket.on('connect', handlers.onConnect);
        socket.on('connect_error', handlers.onConnectError);
        socket.on('disconnect', handlers.onDisconnect);
        socket.on('reconnect', handlers.onReconnect);
        socket.on('new_message', handlers.onNewMessage);
        socket.on('message_read', handlers.onMessageRead);
        socket.on('user_typing', handlers.onUserTyping);

        // 이미 연결된 상태에서 진입하면 즉시 초기 데이터 로드
        if (socket.connected) {
            loadRooms();
        }

    } catch (error) {
        console.error('Socket.IO 초기화 오류:', error);
    }
}
